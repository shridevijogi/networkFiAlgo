import turtle
import tkinter as tk
import pyttsx3
import tkinter.messagebox as messagebox

# Initialize the text-to-speech engine
engine = pyttsx3.init()

def generate_parity_bits(original_data):
    """
    Generate data with row and column parity bits.

    Args:
    - original_data: A 2D list representing the original data matrix.

    Returns:
    - A 2D list representing the data matrix with parity bits included.
    """

    num_rows = len(original_data)
    num_cols = len(original_data[0])

    # Calculate row parities
    row_parity = []
    for row in original_data:
        parity_bit = sum(row) % 2
        row_parity.append(parity_bit)

    # Calculate column parities
    col_parity = []
    for j in range(num_cols):
        col_data = [original_data[i][j] for i in range(num_rows)]
        parity_bit = sum(col_data) % 2
        col_parity.append(parity_bit)

    # Calculate overall row and column parity
    overall_parity = sum(row_parity + col_parity) % 2

    # Append row parities and overall column parity to the original data
    parity_data = []
    for i in range(num_rows):
        row = original_data[i] + [row_parity[i]]
        parity_data.append(row)
    parity_data.append(col_parity + [overall_parity])

    return parity_data

def draw_square():
    for _ in range(4):
        turtle.forward(30)
        turtle.right(90)

def draw_bit(bit):
    turtle.penup()
    turtle.forward(10)
    turtle.pendown()
    turtle.write(bit, align="center", font=("Arial", 12, "normal"))
    turtle.penup()
    turtle.forward(20)
    turtle.pendown()

def draw_matrix(data_matrix, user_data, output_data):
    turtle.speed(2)  # Set turtle speed to 2 (medium)
    turtle.delay(5)  # Add a delay of 5 milliseconds between each turtle movement

    num_rows = len(data_matrix)
    num_cols = len(data_matrix[0])

    # Draw the user data box
    user_data.penup()
    user_data.goto(-200, 240)  # Adjusted position of the user data box
    user_data.pendown()

    for _ in range(2):
        user_data.forward(450)  # Increased width of the box
        user_data.right(90)
        user_data.forward(40)
        user_data.right(90)

    user_data.penup()
    user_data.goto(-190, 220)  # Adjusted position to start writing user data
    user_data.pendown()
    user_data.write("User Data:", align="left", font=("Arial", 12, "bold"))
    user_data.penup()
    user_data.goto(-190, 200)  # Adjusted position to start writing user data bits
    user_data.pendown()

    # Display the user-entered data bits in the box
    user_bits = ""
    for i in range(len(data_matrix) - 1):  # Exclude the last row (parity bits)
        row_bits = "".join(str(bit) for bit in data_matrix[i][:-1])
        user_bits += row_bits + "  "  # Add a little gap between rows

    user_data.write(user_bits, align="left", font=("Arial", 12, "normal"))

    # Draw the matrix with parity bits
    turtle.penup()
    turtle.goto(-150, 120 - num_rows * 30)  # Adjust the y-coordinate for matrix position
    turtle.pendown()

    for i, row in enumerate(data_matrix):
        for j, bit in enumerate(row):
            draw_bit(bit)

        if i == num_rows - 2:  # Draw line before the last row of parity bits
            turtle.penup()
            turtle.goto(-150, turtle.ycor() - 30)
            turtle.pendown()
            turtle.goto(-150 + num_cols * 30, turtle.ycor())

        turtle.penup()
        turtle.goto(-150 + (num_cols - 1) * 30, turtle.ycor() - 30)
        turtle.pendown()
        turtle.goto(-150 + (num_cols - 1) * 30, turtle.ycor() + num_rows * 30)
        turtle.penup()
        turtle.goto(-150, turtle.ycor() - num_rows * 30)
        turtle.pendown()

    # Add a note at the bottom right corner
    note_text = "Note1 : Here the matrix is generated based on the number of 1's\n"
    note_text += "If the number of one's is odd,the sum of each row and column is 1,otherwise 0\n"
    note_text += "and the final bit which is LCR is generated by considering the sum of\n"
    note_text += "1's in final row and column and it is ignored. "
    note = turtle.Turtle()
    note.penup()
    note.goto(110,110)  # Adjusted position for the note
    note.pendown()
    note.write(note_text, align="right", font=("Arial", 10, "italic"))
    note.penup()

    engine.say(note_text)
    engine.runAndWait()



    # Draw the output data box
    output_data.penup()
    output_data.goto(-200, -260)  # Adjusted position of the output data box
    output_data.pendown()

    for _ in range(2):
        output_data.forward(450)  # Increased width of the box
        output_data.right(90)
        output_data.forward(40)
        output_data.right(90)

    output_data.penup()
    output_data.goto(-190, -280)  # Adjusted position to start writing output data
    output_data.pendown()
    output_data.write("Output Data:", align="left", font=("Arial", 12, "bold"))
    output_data.penup()
    output_data.goto(-190, -300)  # Adjusted position to start writing output data bits
    output_data.pendown()

    # Display the output data bits (data + parity bits)
    output_bits = ""
    for i in range(len(data_matrix)):
        row_bits = "".join(str(bit) for bit in data_matrix[i])
        output_bits += row_bits + "  "  # Add a little gap between rows

    output_data.write(output_bits, align="left", font=("Arial", 12, "normal"))

    # Add a note at the bottom right corner
    note_text = "Note2 : Here in output data, the user data is appended with row parities and\n"
    note_text += "the sum of the last row last column is appended alongside with it."
    note = turtle.Turtle()
    note.penup()
    note.goto(530, -50)  # Adjusted position for the note
    note.pendown()
    note.write(note_text, align="right", font=("Arial", 10, "italic"))
    note.penup()


    # Add a note at the bottom right corner
    note_text = "Note2 : Here in output data, the user data is appended with row parities and\n"
    note_text += "the sum of the last row last column is appended alongside with it."
    engine.say(note_text)
    engine.runAndWait()

    turtle.done()

def display_parity_matrix():
    num_rows = row_entry.get()
    num_cols = col_entry.get()

    # Check if rows and columns are empty
    if not num_rows or not num_cols:
        # Display an error messagebox
        messagebox.showerror("Error", "Please enter values for both rows and columns.")
        return

    # Validate if the entered values are integers
    if not num_rows.isdigit() or not num_cols.isdigit():
        # Display an error messagebox
        messagebox.showerror("Error", "Please enter valid integers for rows and columns.")
        return

    num_rows = int(num_rows)
    num_cols = int(num_cols)

    # Check if the data bits for rows and columns are entered correctly
    original_data = []
    for i in range(num_rows):
        row_bits = data_entries[i].get().strip().split()

        if not row_bits:
            # Display an error messagebox and return immediately
            messagebox.showerror("Error", "Data bits cannot be empty.")
            return

        # Check if any entered value is not 0 or 1
        if not all(bit.isdigit() and (bit == '0' or bit == '1') for bit in row_bits):
            # Display an error messagebox
            messagebox.showerror("Error", f"Please enter valid bits (0s and 1s) for row {i + 1}.")
            return

        # Convert the entered values to integers
        row_bits = [int(bit) for bit in row_bits]
        original_data.append(row_bits)

    parity_data = generate_parity_bits(original_data)
    # Rest of the code for drawing the parity matrix...



    # Initialize the Turtle screen
    turtle.setup(800, 600)
    turtle.title("Data Matrix with Parity Bits")
    turtle.bgcolor("peach puff")
    turtle.hideturtle()

    # Create a Turtle to draw the user data box
    user_data = turtle.Turtle()
    user_data.penup()
    user_data.goto(-200, 240)  # Position of the user data box
    user_data.pendown()
    user_data.speed(0)  # Fastest turtle speed

    # Create a Turtle to draw the output data box
    output_data = turtle.Turtle()
    output_data.penup()
    output_data.goto(-200, -260)  # Position of the output data box
    output_data.pendown()
    output_data.speed(0)  # Fastest turtle speed

    # Draw the user data box
    for _ in range(2):
        user_data.forward(450)  # Increased width of the box
        user_data.right(90)
        user_data.forward(40)
        user_data.right(90)

    # Draw the output data box
    for _ in range(2):
        output_data.forward(450)  # Increased width of the box
        output_data.right(90)
        output_data.forward(40)
        output_data.right(90)

    # Create a text box to display the user-entered data
    user_data.penup()
    user_data.goto(-190, 220)  # Position to start writing user data
    user_data.pendown()
    user_data.write("User Data:", align="left", font=("Arial", 12, "bold"))
    user_data.penup()
    user_data.goto(-190, 200)  # Position to start writing user data bits
    user_data.pendown()

    # Create a text box to display the output data
    output_data.penup()
    output_data.goto(-190, -280)  # Position to start writing output data
    output_data.pendown()
    output_data.write("Output Data:", align="left", font=("Arial", 12, "bold"))
    output_data.penup()
    output_data.goto(-190, -300)  # Position to start writing output data bits
    output_data.pendown()

    # Draw the data matrix with parity bits
    draw_matrix(parity_data, user_data, output_data)


    # Keep the Turtle graphics window open until it is closed
    turtle.done()


# Create the Tkinter window
window = tk.Tk()
window.title("Parity Matrix Generator")
window.configure(bg="peach puff")

# Create the input fields for number of rows and columns
row_label = tk.Label(window, text="Enter the number of rows:")
row_label.pack()
row_entry = tk.Entry(window)
row_entry.pack()

col_label = tk.Label(window, text="Enter the number of columns:")
col_label.pack()
col_entry = tk.Entry(window)
col_entry.pack()

# Create the input fields for data bits
data_entries = []


def create_data_entry_fields():
    # Get the number of rows and columns entered
    num_rows = row_entry.get().strip()
    num_cols = col_entry.get().strip()

    # Check if rows and columns are empty
    if not num_rows or not num_cols:
        # Display an error messagebox
        messagebox.showerror("Error", "Please enter valid values for both rows and columns.")
        return

    # Validate if the entered values are integers
    if not num_rows.isdigit() or not num_cols.isdigit():
        # Display an error messagebox
        messagebox.showerror("Error", "Please enter valid integers for rows and columns.")
        return

    # Convert the entered values to integers
    num_rows = int(num_rows)
    num_cols = int(num_cols)

    # Clear the previous data entry fields
    for entry in data_entries:
        entry.destroy()
    data_entries.clear()

    # Create the new data entry fields
    for i in range(num_rows):
        label = tk.Label(window, text=f"Enter the data bits for row {i + 1} (0s and 1s separated by spaces):")
        label.pack()
        entry = tk.Entry(window)
        entry.pack()
        data_entries.append(entry)


# Create the button to update the data entry fields
update_button = tk.Button(window, text="Enter the bits for given rows and columns", command=create_data_entry_fields)
update_button.pack()

# Create the button to display the parity matrix
display_button = tk.Button(window, text="Display Parity Matrix", command=display_parity_matrix)
display_button.pack()

# Start the Tkinter event loop
window.mainloop()

# Start the Tkinter event loop
window.mainloop() 
